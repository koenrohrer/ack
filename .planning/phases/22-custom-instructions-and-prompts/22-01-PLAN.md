---
phase: 22-custom-instructions-and-prompts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adapters/copilot/parsers/instructions.parser.ts
  - src/adapters/copilot/parsers/prompts.parser.ts
  - src/adapters/copilot/copilot.adapter.ts
  - src/views/tool-tree/tool-tree.model.ts
autonomous: true
requirements:
  - INST-01
  - INST-02
  - INST-03

must_haves:
  truths:
    - "Copilot instructions and prompt files appear in the sidebar under 'Custom Prompts' when Copilot is active and .github/ files exist"
    - "copilot-instructions.md is listed as the always-on global instructions entry"
    - "Each .instructions.md file is listed with its applyTo scope when frontmatter has applyTo"
    - "Each .prompt.md file is listed with its description when frontmatter has description"
    - "Empty .github/ directories result in an empty (but visible) Custom Prompts group, not an error"
    - "No workspace open results in empty array, not a crash"
  artifacts:
    - path: "src/adapters/copilot/parsers/instructions.parser.ts"
      provides: "parseCopilotInstructions() — reads global copilot-instructions.md + all .instructions.md files"
      exports: ["parseCopilotInstructions"]
    - path: "src/adapters/copilot/parsers/prompts.parser.ts"
      provides: "parseCopilotPrompts() — reads all .prompt.md files"
      exports: ["parseCopilotPrompts"]
    - path: "src/adapters/copilot/copilot.adapter.ts"
      provides: "readTools() wired for ToolType.CustomPrompt at ConfigScope.Project"
      contains: "parseCopilotInstructions"
    - path: "src/views/tool-tree/tool-tree.model.ts"
      provides: "APPLICABLE_SCOPES[ToolType.CustomPrompt] includes ConfigScope.Project"
      contains: "ConfigScope.Project"
  key_links:
    - from: "src/views/tool-tree/tool-tree.model.ts"
      to: "src/adapters/copilot/copilot.adapter.ts"
      via: "configService.readToolsByScope(ToolType.CustomPrompt, ConfigScope.Project)"
      pattern: "CustomPrompt.*Project"
    - from: "src/adapters/copilot/copilot.adapter.ts"
      to: "src/adapters/copilot/parsers/instructions.parser.ts"
      via: "parseCopilotInstructions(this.fileIO, this.workspaceRoot)"
      pattern: "parseCopilotInstructions"
    - from: "src/adapters/copilot/copilot.adapter.ts"
      to: "src/adapters/copilot/parsers/prompts.parser.ts"
      via: "parseCopilotPrompts(this.fileIO, this.workspaceRoot)"
      pattern: "parseCopilotPrompts"
---

<objective>
Create the two Copilot instruction/prompt parsers and wire them into CopilotAdapter.readTools(). Extend APPLICABLE_SCOPES in the tree model to include ConfigScope.Project for CustomPrompt so the tree queries the right scope.

Purpose: INST-01, INST-02, INST-03 — users can see their .github/ instruction and prompt files in the sidebar.
Output: Two new parser files, updated readTools() in CopilotAdapter, updated APPLICABLE_SCOPES in tool-tree.model.ts.
</objective>

<execution_context>
@/Users/koenrohrer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/koenrohrer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-custom-instructions-and-prompts/22-RESEARCH.md
@src/adapters/copilot/copilot.adapter.ts
@src/adapters/copilot/paths.ts
@src/views/tool-tree/tool-tree.model.ts
@src/adapters/codex/parsers/prompt.parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create instructions.parser.ts</name>
  <files>src/adapters/copilot/parsers/instructions.parser.ts</files>
  <action>
Create NEW file `src/adapters/copilot/parsers/instructions.parser.ts`.

This parser reads two kinds of Copilot instruction files:
1. The single always-on `copilot-instructions.md` at `.github/copilot-instructions.md`
2. All `*.instructions.md` files in `.github/instructions/`

Export one function: `parseCopilotInstructions(fileIO, workspaceRoot)`.

Implementation details:
- Import: `path` (built-in), `FileIOService` from `../../../services/fileio.service.js`, `NormalizedTool` from `../../../types/config.js`, `ToolType, ConfigScope, ToolStatus` from `../../../types/enums.js`, `extractFrontmatter` from `../../../utils/markdown.js`, `CopilotPaths` from `../paths.js`
- Use `CopilotPaths.workspaceCopilotInstructionsFile(workspaceRoot)` for the global file path
- Use `CopilotPaths.workspaceInstructionsDir(workspaceRoot)` for the instructions directory
- Read global file: `await fileIO.readTextFile(globalPath)` — if `null`, skip (file doesn't exist yet)
- For global file: build NormalizedTool with:
  - `id: 'instruction:project:copilot-instructions'`
  - `type: ToolType.CustomPrompt`, `scope: ConfigScope.Project`, `status: ToolStatus.Enabled`
  - `name: 'copilot-instructions'`
  - `description: 'Always-on Copilot instructions (applies to all chats)'`
  - `source: { filePath: globalPath, isDirectory: false }`
  - `metadata: { instructionKind: 'global', body: fm?.body ?? globalContent }`
  - Note: `fm` is result of `extractFrontmatter(globalContent)` — may be `null` if no `---`; always use null-safe `??` fallback
- List per-file instructions: `await fileIO.listFiles(instructionsDir, '.instructions.md')` — returns `[]` on ENOENT
- For each file in the listing:
  - Read content via `fileIO.readTextFile(filePath)` — skip if `null`
  - `baseName = path.basename(filename, '.instructions.md')`
  - `fm = extractFrontmatter(content)` — may be `null`
  - `applyTo = fm?.frontmatter['applyTo']` — may be `undefined`
  - `description = fm?.frontmatter['description']`
  - Build NormalizedTool with:
    - `id: \`instruction:project:${baseName}\``
    - `name: baseName`
    - `description: description ?? (applyTo ? \`Applies to: ${applyTo}\` : undefined)`
    - `scope: ConfigScope.Project`, `status: ToolStatus.Enabled`, `type: ToolType.CustomPrompt`
    - `source: { filePath: path.join(instructionsDir, filename), isDirectory: false }`
    - `metadata: { instructionKind: 'file-pattern', applyTo, body: fm?.body ?? content }`
- Sort tools alphabetically by name before return: `tools.sort((a, b) => a.name.localeCompare(b.name))`
- Return `tools` array (may be empty if no files exist)
  </action>
  <verify>
TypeScript compiles without errors: `npm run compile` (or the project's build command — check package.json scripts). If no compile step, check for TypeScript errors via `npx tsc --noEmit`.
  </verify>
  <done>
`src/adapters/copilot/parsers/instructions.parser.ts` exists, exports `parseCopilotInstructions`, handles null-safe frontmatter extraction, uses compound extension `.instructions.md` in listFiles, and TypeScript reports no type errors in this file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create prompts.parser.ts</name>
  <files>src/adapters/copilot/parsers/prompts.parser.ts</files>
  <action>
Create NEW file `src/adapters/copilot/parsers/prompts.parser.ts`.

Export one function: `parseCopilotPrompts(fileIO, workspaceRoot)`.

Implementation details:
- Import: `path`, `FileIOService`, `NormalizedTool`, `ToolType, ConfigScope, ToolStatus`, `extractFrontmatter`, `CopilotPaths`
- Use `CopilotPaths.workspacePromptsDir(workspaceRoot)` for the directory path
- List files: `await fileIO.listFiles(promptsDir, '.prompt.md')` — returns `[]` on ENOENT
- For each file:
  - `filePath = path.join(promptsDir, filename)`
  - Read via `fileIO.readTextFile(filePath)` — skip if `null`
  - `baseName = path.basename(filename, '.prompt.md')`
  - `fm = extractFrontmatter(content)` — may be `null`
  - `description = fm?.frontmatter['description']`
  - `mode = fm?.frontmatter['mode'] ?? fm?.frontmatter['agent']` — Copilot uses both field names; prefer `mode`
  - Build NormalizedTool with:
    - `id: \`prompt:project:${baseName}\``
    - `type: ToolType.CustomPrompt`, `scope: ConfigScope.Project`, `status: ToolStatus.Enabled`
    - `name: baseName`
    - `description`
    - `source: { filePath, isDirectory: false }`
    - `metadata: { instructionKind: 'prompt', mode, body: fm?.body ?? content }`
- Sort alphabetically by name before return
- Return `tools` array (may be empty)

Note: `tools` array in prompt frontmatter (YAML array) is NOT parseable by `extractFrontmatter()` (flat k/v only). Do not attempt to parse it — this is acceptable for Phase 22.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit` from project root.
  </verify>
  <done>
`src/adapters/copilot/parsers/prompts.parser.ts` exists, exports `parseCopilotPrompts`, uses compound extension `.prompt.md` in listFiles, handles null-safe frontmatter, and TypeScript reports no type errors in this file.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire parsers into CopilotAdapter + extend APPLICABLE_SCOPES</name>
  <files>
    src/adapters/copilot/copilot.adapter.ts
    src/views/tool-tree/tool-tree.model.ts
  </files>
  <action>
Two edits:

**A. src/adapters/copilot/copilot.adapter.ts**

1. Add two new import statements near the top (after the existing `parseCopilotMcpFile` import):
   ```typescript
   import { parseCopilotInstructions } from './parsers/instructions.parser.js';
   import { parseCopilotPrompts } from './parsers/prompts.parser.js';
   ```

2. Replace the existing `readTools()` implementation. The current stub returns `[]` for non-McpServer types. Replace the entire method body with:
   ```typescript
   async readTools(type: ToolType, scope: ConfigScope): Promise<NormalizedTool[]> {
     if (type === ToolType.McpServer) {
       if (scope === ConfigScope.Project) {
         if (!this.workspaceRoot) return [];
         return parseCopilotMcpFile(
           this.fileIO,
           this.schemaService,
           CopilotPaths.workspaceMcpJson(this.workspaceRoot),
           scope,
         );
       }
       if (scope === ConfigScope.User) {
         return parseCopilotMcpFile(
           this.fileIO,
           this.schemaService,
           CopilotPaths.userMcpJson(this.vsCodeUserDir),
           scope,
         );
       }
       return [];
     }
     if (type === ToolType.CustomPrompt && scope === ConfigScope.Project) {
       if (!this.workspaceRoot) return [];
       const instructions = await parseCopilotInstructions(this.fileIO, this.workspaceRoot);
       const prompts = await parseCopilotPrompts(this.fileIO, this.workspaceRoot);
       return [...instructions, ...prompts];
     }
     return [];
   }
   ```
   Update the JSDoc comment above the method to mention Phase 22 CustomPrompt support is now implemented.

**B. src/views/tool-tree/tool-tree.model.ts**

Change line 55 — the `APPLICABLE_SCOPES` entry for `CustomPrompt`:
```typescript
// Before:
[ToolType.CustomPrompt]: [ConfigScope.User],

// After:
[ToolType.CustomPrompt]: [ConfigScope.User, ConfigScope.Project],
```

This change enables the tree model to query `ConfigScope.Project` for CustomPrompt tools, which is required for Copilot instructions and prompts (all project-scoped).

Important: Codex prompts are User-scoped only. After this change, the tree model will also call `CodexAdapter.readTools(ToolType.CustomPrompt, ConfigScope.Project)`. Verify that the Codex adapter returns `[]` for project scope (it should — the existing Codex readCustomPrompts method has a scope guard). Do not modify CodexAdapter.
  </action>
  <verify>
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npm test` — existing test suite passes (no regressions in Codex prompt tests)
3. In Extension Development Host with a workspace that has `.github/copilot-instructions.md` and/or `.github/instructions/*.instructions.md` and Copilot active: the "Custom Prompts" group in the sidebar shows these files.
  </verify>
  <done>
CopilotAdapter.readTools() returns instructions and prompts for ToolType.CustomPrompt + ConfigScope.Project. APPLICABLE_SCOPES[CustomPrompt] includes both User and Project. TypeScript compiles clean. Existing Codex prompt tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors
2. `npm test` — all tests pass (especially parsers.test.ts, writers.test.ts)
3. Files exist: `src/adapters/copilot/parsers/instructions.parser.ts`, `src/adapters/copilot/parsers/prompts.parser.ts`
4. `grep -n 'parseCopilotInstructions\|parseCopilotPrompts' src/adapters/copilot/copilot.adapter.ts` — both imports found
5. `grep -n 'ConfigScope.Project' src/views/tool-tree/tool-tree.model.ts` — appears in CustomPrompt APPLICABLE_SCOPES line
</verification>

<success_criteria>
- parseCopilotInstructions reads global instructions file (null-safe) and all .instructions.md files (compound extension)
- parseCopilotPrompts reads all .prompt.md files (compound extension), extracts description and mode
- CopilotAdapter.readTools merges both for CustomPrompt/Project scope with workspaceRoot guard
- APPLICABLE_SCOPES[CustomPrompt] = [User, Project] — tree model queries both scopes
- TypeScript: zero errors. Tests: all passing.
</success_criteria>

<output>
After completion, create `.planning/phases/22-custom-instructions-and-prompts/22-01-SUMMARY.md`
</output>
