---
phase: 22-custom-instructions-and-prompts
plan: 04
type: execute
wave: 3
depends_on:
  - 22-03
files_modified:
  - src/adapters/copilot/copilot.adapter.ts
  - src/views/marketplace/marketplace.panel.ts
autonomous: false
requirements:
  - INST-01
  - INST-02
  - INST-03
  - INST-04
  - INST-05
  - INST-06

must_haves:
  truths:
    - "A marketplace tool entry with toolType 'custom_prompt' installs to .github/ when Copilot is active"
    - "The scope QuickPick is skipped for custom_prompt installs when Copilot is active (auto-selects Project)"
    - "The correct .github/ subdirectory is chosen based on filename extension (.instructions.md or .prompt.md)"
    - "Human verification confirms all six INST requirements end-to-end in Extension Development Host"
  artifacts:
    - path: "src/adapters/copilot/copilot.adapter.ts"
      provides: "installInstruction(scope, filename, content) method"
      exports: ["installInstruction"]
    - path: "src/views/marketplace/marketplace.panel.ts"
      provides: "custom_prompt branch in handleRepoInstall with auto-Project scope for Copilot"
      contains: "custom_prompt"
  key_links:
    - from: "src/views/marketplace/marketplace.panel.ts"
      to: "src/adapters/copilot/copilot.adapter.ts"
      via: "(adapter as CopilotAdapter).installInstruction(scope, fileName, content)"
      pattern: "installInstruction"
    - from: "src/adapters/copilot/copilot.adapter.ts"
      to: "src/services/fileio.service.ts"
      via: "this.fileIO.writeTextFile(targetPath, content)"
      pattern: "writeTextFile"
---

<objective>
Add installInstruction() to CopilotAdapter and wire the custom_prompt branch in marketplace.panel.ts handleRepoInstall. Then run human verification of all six INST requirements in the Extension Development Host.

Purpose: INST-04 (marketplace install). The human checkpoint covers all six INST requirements end-to-end.
Output: Updated copilot.adapter.ts, updated marketplace.panel.ts, human sign-off on all INST requirements.
</objective>

<execution_context>
@/Users/koenrohrer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/koenrohrer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-custom-instructions-and-prompts/22-RESEARCH.md
@src/adapters/copilot/copilot.adapter.ts
@src/views/marketplace/marketplace.panel.ts
@.planning/phases/22-custom-instructions-and-prompts/22-01-SUMMARY.md
@.planning/phases/22-custom-instructions-and-prompts/22-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add installInstruction() to CopilotAdapter</name>
  <files>src/adapters/copilot/copilot.adapter.ts</files>
  <action>
Add a new public method `installInstruction` to CopilotAdapter, after the existing `installMcpServer` method and before `getMcpFilePath`. This is a Copilot-specific method (not on IInstallAdapter interface — Option A from research).

```typescript
// ---------------------------------------------------------------------------
// Copilot-specific -- installInstruction
// ---------------------------------------------------------------------------

/**
 * Install an instruction or prompt file to the correct .github/ subdirectory.
 *
 * Routes by filename extension:
 * - 'copilot-instructions.md'  -> .github/copilot-instructions.md
 * - '*.instructions.md'        -> .github/instructions/<filename>
 * - '*.prompt.md'              -> .github/prompts/<filename>
 *
 * Uses fileIO.writeTextFile() for atomic write with auto-mkdir.
 */
async installInstruction(
  _scope: ConfigScope,
  filename: string,
  content: string,
): Promise<void> {
  if (!this.workspaceRoot) {
    throw new AdapterScopeError('GitHub Copilot', _scope, 'installInstruction (no workspace open)');
  }
  let targetPath: string;
  if (filename === 'copilot-instructions.md') {
    targetPath = CopilotPaths.workspaceCopilotInstructionsFile(this.workspaceRoot);
  } else if (filename.endsWith('.instructions.md')) {
    targetPath = path.join(CopilotPaths.workspaceInstructionsDir(this.workspaceRoot), filename);
  } else if (filename.endsWith('.prompt.md')) {
    targetPath = path.join(CopilotPaths.workspacePromptsDir(this.workspaceRoot), filename);
  } else {
    throw new Error(
      `CopilotAdapter: unrecognized instruction/prompt filename: '${filename}'. ` +
      `Expected 'copilot-instructions.md', '*.instructions.md', or '*.prompt.md'.`,
    );
  }
  await this.fileIO.writeTextFile(targetPath, content);
}
```

Note: `this.fileIO.writeTextFile()` uses `write-file-atomic` internally and auto-creates parent directories — no manual `mkdir` needed.
  </action>
  <verify>
`npx tsc --noEmit` — zero TypeScript errors. `grep -n 'installInstruction' src/adapters/copilot/copilot.adapter.ts` — method definition found.
  </verify>
  <done>
CopilotAdapter has public `installInstruction(_scope, filename, content)` method that routes by filename extension and delegates to fileIO.writeTextFile. TypeScript clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire custom_prompt branch in marketplace handleRepoInstall</name>
  <files>src/views/marketplace/marketplace.panel.ts</files>
  <action>
In `marketplace.panel.ts`, find the `handleRepoInstall` private method. It currently has three branches:
- `toolEntry.toolType === 'skill'`
- `toolEntry.toolType === 'command'`
- `toolEntry.toolType === 'mcp_server'`

Add a fourth branch for `'custom_prompt'` BEFORE the closing of the try block (after the mcp_server branch, before the success postMessage call). The branch must:

1. Auto-select `ConfigScope.Project` for Copilot instructions (skip promptForScope):

```typescript
} else if (toolEntry.toolType === 'custom_prompt') {
  // Custom prompts are always project-scoped for Copilot
  const cpScope = ConfigScope.Project;

  const content = await this.repoScanner.fetchRepoFile(
    repoFullName!,
    defaultBranch!,
    repoPath!,
  );
  const fileName = repoPath!.split('/').pop()!;

  // Cast to CopilotAdapter — only Copilot supports custom_prompt installs
  const { CopilotAdapter } = await import('../../adapters/copilot/copilot.adapter.js');
  if (!(adapter instanceof CopilotAdapter)) {
    throw new Error('custom_prompt install is only supported for the Copilot adapter.');
  }
  await adapter.installInstruction(cpScope, fileName, content);
}
```

Important: The `handleRepoInstall` method calls `this.promptForScope(toolEntry.name)` at the top before the if/else branches, and the returned scope is used by skill/command/mcp_server. For custom_prompt, we ignore the returned scope and use `ConfigScope.Project` directly. However, to avoid modifying the existing control flow (which may early-return on `scope === undefined`), add the custom_prompt branch in the if/else chain BEFORE the promptForScope call would be an issue.

Actually, reading the current code: `promptForScope` is called unconditionally before the if/else branches and may cancel the install (returns undefined). To fix this for custom_prompt (which should never show the scope QuickPick), restructure:

Option: Move the `promptForScope` call inside the non-custom_prompt branches. Before the if/else, check if `toolEntry.toolType === 'custom_prompt'` and handle it early return if adapter is not copilot:

```typescript
// At the top of handleRepoInstall, before promptForScope:
if (toolEntry.toolType === 'custom_prompt') {
  // Handle directly — no scope QuickPick for Copilot instructions
  await this.handleCustomPromptInstall(toolId, toolEntry);
  return;
}

const scope = await this.promptForScope(toolEntry.name);
// ... rest of existing flow
```

Then add a new private method `handleCustomPromptInstall`:

```typescript
private async handleCustomPromptInstall(
  toolId: string,
  toolEntry: { repoFullName?: string; defaultBranch?: string; repoPath?: string; name: string },
): Promise<void> {
  const adapter = this.getAdapter();
  const { CopilotAdapter } = await import('../../adapters/copilot/copilot.adapter.js');
  if (!(adapter instanceof CopilotAdapter)) {
    this.postMessage({ type: 'installError', toolId, error: 'custom_prompt install requires Copilot.' });
    return;
  }

  this.postMessage({ type: 'installProgress', toolId, status: 'downloading' });
  try {
    const content = await this.repoScanner.fetchRepoFile(
      toolEntry.repoFullName!,
      toolEntry.defaultBranch!,
      toolEntry.repoPath!,
    );
    const fileName = toolEntry.repoPath!.split('/').pop()!;
    await adapter.installInstruction(ConfigScope.Project, fileName, content);

    this.postMessage({ type: 'installComplete', toolId, scope: ConfigScope.Project as string });
    void vscode.window.showInformationMessage(`Installed "${toolEntry.name}"`);

    const installedTools = await this.getInstalledTools();
    this.postMessage({ type: 'installedTools', tools: installedTools });
    void vscode.commands.executeCommand('ack.refreshToolTree');
  } catch (err: unknown) {
    const errorMsg = err instanceof Error ? err.message : 'Install failed';
    this.postMessage({ type: 'installError', toolId, error: errorMsg });
  }
}
```

Choose whichever approach (inline branch or private method) keeps the change minimal and clean. The private method approach is preferred for readability. Use the actual type of toolEntry from the existing code (check what `this.toolEntryMap.get(toolId)` returns — it's the ToolManifest or a registry entry type).
  </action>
  <verify>
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npm test` — all tests pass
3. `grep -n 'custom_prompt' src/views/marketplace/marketplace.panel.ts` — found in new branch/method
4. `grep -n 'installInstruction' src/views/marketplace/marketplace.panel.ts` — found in new branch/method
  </verify>
  <done>
marketplace.panel.ts handles custom_prompt toolType: fetches file from repo, casts to CopilotAdapter, calls installInstruction(Project, filename, content). Scope QuickPick is NOT shown for custom_prompt installs. TypeScript clean. Tests pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verification — all INST requirements end-to-end</name>
  <action>Verify all six INST requirements (INST-01 through INST-06) work end-to-end in the running Extension Development Host by following the steps in how-to-verify.</action>
  <what-built>
Phase 22 complete implementation:
- Plan 01: instructions.parser.ts + prompts.parser.ts created; CopilotAdapter.readTools() wired for CustomPrompt/Project; APPLICABLE_SCOPES extended
- Plan 02: Parser test suite (RED then GREEN)
- Plan 03: CopilotAdapter.removeTool() for CustomPrompt; ack.deletePrompt extended; ack.installInstructionFromFile command added; package.json updated
- Plan 04 (this plan): CopilotAdapter.installInstruction(); marketplace custom_prompt branch
  </what-built>
  <how-to-verify>
Launch Extension Development Host: press F5 in VS Code.

Open a workspace with these test files pre-created:
- `.github/copilot-instructions.md` with content: "# Copilot Instructions\nBe concise."
- `.github/instructions/typescript.instructions.md` with frontmatter: `---\napplyTo: "**/*.ts"\n---\nUse TypeScript strict mode.`
- `.github/prompts/refactor.prompt.md` with frontmatter: `---\ndescription: Refactor selected code\n---\nRefactor the following...`

Ensure GitHub Copilot or GitHub Copilot Chat extension is installed in the Extension Development Host.

**INST-01: Always-on instructions file visible**
1. Switch to Copilot agent in status bar
2. Look at sidebar "Custom Prompts" section
3. EXPECT: `copilot-instructions` appears with description "Always-on Copilot instructions (applies to all chats)"

**INST-02: Per-file instructions visible with applyTo scope**
1. In same sidebar state
2. EXPECT: `typescript` appears under Custom Prompts, description shows "Applies to: **/*.ts"

**INST-03: Prompt files visible**
1. In same sidebar state
2. EXPECT: `refactor` appears under Custom Prompts, description shows "Refactor selected code"

**INST-04: Marketplace install**
1. Open marketplace panel
2. If there is a registry entry with toolType: 'custom_prompt' (may need to add a test entry to a local repo) — install it
3. EXPECT: File appears in .github/instructions/ or .github/prompts/ depending on its extension
4. EXPECT: No scope QuickPick appeared during install
5. EXPECT: Sidebar refreshes to show the new file

**INST-05: Delete from sidebar**
1. Right-click on `refactor` in the sidebar
2. Click "Delete"
3. EXPECT: Modal confirmation appears with "This action cannot be undone."
4. Click Delete to confirm
5. EXPECT: `.github/prompts/refactor.prompt.md` is removed from disk
6. EXPECT: Sidebar refreshes and `refactor` is gone

**INST-06: Markdown preview**
1. Click on `copilot-instructions` in the sidebar
2. EXPECT: VS Code markdown preview opens showing "# Copilot Instructions\nBe concise."
3. Click on `typescript` in the sidebar
4. EXPECT: Markdown preview shows the typescript instructions content
  </how-to-verify>
  <resume-signal>Type "approved" if all 6 INST requirements pass. Describe any failures if issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors
2. `npm test` — all tests pass
3. Human checkpoint: all INST-01 through INST-06 verified in Extension Development Host
</verification>

<success_criteria>
- CopilotAdapter.installInstruction() writes to correct .github/ path based on filename extension
- Marketplace handles custom_prompt toolType without showing scope QuickPick for Copilot
- All six INST requirements human-verified in Extension Development Host
- TypeScript: zero errors. Tests: all passing.
</success_criteria>

<output>
After completion, create `.planning/phases/22-custom-instructions-and-prompts/22-04-SUMMARY.md`
</output>
