---
phase: 22-custom-instructions-and-prompts
plan: 03
type: execute
wave: 2
depends_on:
  - 22-01
files_modified:
  - src/adapters/copilot/copilot.adapter.ts
  - src/views/tool-tree/tool-tree.management.ts
  - package.json
autonomous: true
requirements:
  - INST-05
  - INST-06

must_haves:
  truths:
    - "Right-clicking a Copilot instruction or prompt file in the sidebar shows a Delete option"
    - "Confirming delete removes the file from .github/ and refreshes the sidebar"
    - "Clicking a Copilot instruction or prompt file opens its markdown content in VS Code's markdown preview"
    - "ack.installInstructionFromFile file picker command is registered and only available when Copilot is active"
  artifacts:
    - path: "src/adapters/copilot/copilot.adapter.ts"
      provides: "removeTool() handles ToolType.CustomPrompt via fs.rm(tool.source.filePath)"
      contains: "ToolType.CustomPrompt"
    - path: "src/views/tool-tree/tool-tree.management.ts"
      provides: "deletePrompt command extended to copilot; ack.installInstructionFromFile command registered"
      contains: "installInstructionFromFile"
    - path: "package.json"
      provides: "ack.installInstructionFromFile command and menu entries registered"
      contains: "installInstructionFromFile"
  key_links:
    - from: "src/views/tool-tree/tool-tree.management.ts"
      to: "src/adapters/copilot/copilot.adapter.ts"
      via: "adapter.removeTool(tool) called in deletePromptCmd for copilot adapter"
      pattern: "removeTool"
    - from: "package.json"
      to: "src/views/tool-tree/tool-tree.management.ts"
      via: "ack.installInstructionFromFile command registered in both places"
      pattern: "installInstructionFromFile"
---

<objective>
Implement delete and file-picker install for Copilot instruction and prompt files. Extend the existing deletePrompt command to accept the copilot adapter. Wire removeTool() in CopilotAdapter for CustomPrompt. Add ack.installInstructionFromFile command.

Purpose: INST-05 (delete), INST-06 (preview — already works via ack.openToolSource, just needs delete guard fixed). The preview route for ToolType.CustomPrompt already returns 'markdown' — no code change needed there.
Output: Updated copilot.adapter.ts, tool-tree.management.ts, package.json.
</objective>

<execution_context>
@/Users/koenrohrer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/koenrohrer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-custom-instructions-and-prompts/22-RESEARCH.md
@src/adapters/copilot/copilot.adapter.ts
@src/views/tool-tree/tool-tree.management.ts
@package.json
@.planning/phases/22-custom-instructions-and-prompts/22-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement removeTool for CustomPrompt in CopilotAdapter</name>
  <files>src/adapters/copilot/copilot.adapter.ts</files>
  <action>
Replace the existing `removeTool()` method body in `copilot.adapter.ts`. Current implementation throws for non-McpServer types. Extend to handle `ToolType.CustomPrompt`:

```typescript
async removeTool(tool: NormalizedTool): Promise<void> {
  this.ensureWriteServices();
  if (tool.type === ToolType.McpServer) {
    const filePath = this.getMcpFilePath(tool.scope);
    await removeCopilotMcpServer(this.configService!, filePath, tool.name);
    return;
  }
  if (tool.type === ToolType.CustomPrompt) {
    // Direct file deletion — instruction/prompt files are single .md files
    const { rm } = await import('fs/promises');
    await rm(tool.source.filePath);
    return;
  }
  throw new Error(`CopilotAdapter: removeTool not implemented for ${tool.type} (Phase 23+)`);
}
```

Update the JSDoc comment on removeTool to mention CustomPrompt is now handled.

No other changes to this file in this task — the `installInstruction` method is added in Plan 04.
  </action>
  <verify>
`npx tsc --noEmit` — zero TypeScript errors.
  </verify>
  <done>
copilot.adapter.ts removeTool() handles both McpServer and CustomPrompt. Throws for other types (Phase 23+ message). TypeScript clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend deletePrompt command + add installInstructionFromFile command</name>
  <files>src/views/tool-tree/tool-tree.management.ts</files>
  <action>
Two edits in `tool-tree.management.ts`:

**A. Extend deletePromptCmd to allow copilot adapter**

Find the `ack.deletePrompt` command handler (around line 782). Currently it calls `fs.rm(tool.source.filePath)` directly without an adapter id check (the check was only on `installPromptFromFile`). But per RESEARCH.md, the delete command itself does NOT have an adapter id guard — it operates on `tool.source.filePath` which works the same for both Codex and Copilot.

Read the actual current deletePrompt implementation carefully. If there is no adapter id guard on the delete command, no change is needed to deletePromptCmd logic itself. The `rm(tool.source.filePath)` call already works for Copilot .github/ files.

However, if there is an adapter guard — change `adapter.id !== 'codex'` checks to:
```typescript
const allowedAdapters = new Set(['codex', 'copilot']);
if (!adapter || !allowedAdapters.has(adapter.id)) {
  vscode.window.showErrorMessage('Delete is only available for Codex and Copilot.');
  return;
}
```

**B. Add ack.installInstructionFromFile command**

Add a new command registration block BEFORE the `context.subscriptions.push(...)` call at the bottom of the file. Add it in the same section where `installPromptCmd` and `deletePromptCmd` are defined. Model it closely on `installPromptCmd` (around line 715).

```typescript
// ---------------------------------------------------------------------------
// Install Instruction or Prompt from File (Copilot only)
// ---------------------------------------------------------------------------

const installInstructionCmd = vscode.commands.registerCommand(
  'ack.installInstructionFromFile',
  async () => {
    try {
      const adapter = registry.getActiveAdapter();
      if (!adapter || adapter.id !== 'copilot') {
        vscode.window.showErrorMessage('Install instruction is only available for Copilot.');
        return;
      }

      const uris = await vscode.window.showOpenDialog({
        canSelectMany: false,
        canSelectFolders: false,
        filters: { 'Markdown': ['md'] },
        title: 'Install Copilot Instruction or Prompt',
      });

      if (!uris || uris.length === 0) {
        return;
      }

      const sourcePath = uris[0].fsPath;
      const filename = path.basename(sourcePath);

      // Validate extension — must be .instructions.md or .prompt.md
      if (!filename.endsWith('.instructions.md') && !filename.endsWith('.prompt.md')) {
        vscode.window.showErrorMessage(
          `File must end in .instructions.md or .prompt.md. Got: '${filename}'`,
        );
        return;
      }

      // Import CopilotPaths locally to avoid adapter boundary violation
      const { CopilotPaths } = await import('../../adapters/copilot/paths.js');
      const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
      if (!workspaceRoot) {
        vscode.window.showErrorMessage('No workspace folder open. Cannot install instruction.');
        return;
      }

      const targetDir = filename.endsWith('.instructions.md')
        ? CopilotPaths.workspaceInstructionsDir(workspaceRoot)
        : CopilotPaths.workspacePromptsDir(workspaceRoot);

      const targetPath = path.join(targetDir, filename);
      const { access, mkdir, copyFile } = await import('fs/promises');

      // Check for existing file
      let exists = false;
      try {
        await access(targetPath);
        exists = true;
      } catch {
        // File doesn't exist
      }

      if (exists) {
        const choice = await vscode.window.showWarningMessage(
          `'${filename}' already exists. Overwrite?`,
          { modal: true },
          'Overwrite',
        );
        if (choice !== 'Overwrite') {
          return;
        }
      }

      await mkdir(targetDir, { recursive: true });
      await copyFile(sourcePath, targetPath);

      await treeProvider.refresh();
      vscode.window.showInformationMessage(`Installed '${filename}'.`);
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      vscode.window.showErrorMessage(`Failed to install instruction: ${msg}`);
    }
  },
);
```

Add `installInstructionCmd` to the `context.subscriptions.push(...)` call alongside the other commands.
  </action>
  <verify>
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npm test` — all tests pass (no regressions)
3. Grep: `grep -n 'installInstructionFromFile' src/views/tool-tree/tool-tree.management.ts` — returns two lines (registration + subscriptions push)
  </verify>
  <done>
ack.installInstructionFromFile command registered and pushed to subscriptions. deletePrompt command works for copilot adapter. TypeScript clean. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register command and menu entries in package.json</name>
  <files>package.json</files>
  <action>
Add `ack.installInstructionFromFile` to package.json in two places:

**A. "commands" array** — add entry:
```json
{
  "command": "ack.installInstructionFromFile",
  "title": "ACK: Install Instruction or Prompt from File",
  "icon": "$(file-add)"
}
```

**B. "menus" > "view/item/context"** — add two entries (inline button + context menu):
```json
{
  "command": "ack.installInstructionFromFile",
  "when": "view == ack.toolTree && viewItem == group:custom_prompt",
  "group": "inline"
},
{
  "command": "ack.installInstructionFromFile",
  "when": "view == ack.toolTree && viewItem == group:custom_prompt",
  "group": "1_install"
}
```

Note: The `when` clause does not check `ack.activeAgent == copilot` because that context key may not exist. The command handler itself performs the adapter id check and shows an error message if not Copilot. This is the same pattern used by other commands in this codebase.

Place the new entries adjacent to similar `ack.installPromptFromFile` entries so they are easy to find.
  </action>
  <verify>
1. `npx tsc --noEmit` — zero TypeScript errors (package.json changes don't affect TypeScript, but rebuild ensures no side effects)
2. `npm run build` or equivalent — extension builds without errors
3. `grep -n 'installInstructionFromFile' package.json` — appears in both commands array and menus
  </verify>
  <done>
ack.installInstructionFromFile appears in package.json commands array (with title and icon) and in view/item/context menus for group:custom_prompt. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors
2. `npm test` — all tests pass
3. `grep -n 'installInstructionFromFile' src/views/tool-tree/tool-tree.management.ts package.json` — found in both files
4. `grep -n 'ToolType.CustomPrompt' src/adapters/copilot/copilot.adapter.ts` — appears in removeTool()
</verification>

<success_criteria>
- CopilotAdapter.removeTool() deletes the file at tool.source.filePath for CustomPrompt type
- ack.deletePrompt works for copilot adapter (either no guard or extended guard)
- ack.installInstructionFromFile registered in management.ts, subscriptions, and package.json
- Package.json has command entry + two menu entries for group:custom_prompt context
- TypeScript: zero errors. Tests: all passing.
</success_criteria>

<output>
After completion, create `.planning/phases/22-custom-instructions-and-prompts/22-03-SUMMARY.md`
</output>
