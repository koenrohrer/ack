---
phase: 22-custom-instructions-and-prompts
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/adapters/copilot/parsers/instructions.parser.test.ts
  - src/adapters/copilot/parsers/prompts.parser.test.ts
autonomous: true
requirements:
  - INST-01
  - INST-02
  - INST-03

must_haves:
  truths:
    - "Tests go RED before Plan 01 ships and GREEN after"
    - "Parser tests cover the extractFrontmatter null-return path (files without --- delimiters)"
    - "Parser tests cover missing directory (ENOENT) returning empty array, not throwing"
    - "Parser tests verify compound extensions (.instructions.md, .prompt.md) are used, not plain .md"
    - "All tests pass after Plan 01 implementation is in place"
  artifacts:
    - path: "src/adapters/copilot/parsers/instructions.parser.test.ts"
      provides: "Test suite for parseCopilotInstructions covering global file, per-file instructions, no frontmatter, missing dir"
      min_lines: 80
    - path: "src/adapters/copilot/parsers/prompts.parser.test.ts"
      provides: "Test suite for parseCopilotPrompts covering .prompt.md files, no frontmatter, missing dir"
      min_lines: 50
  key_links:
    - from: "src/adapters/copilot/parsers/instructions.parser.test.ts"
      to: "src/adapters/copilot/parsers/instructions.parser.ts"
      via: "import { parseCopilotInstructions }"
      pattern: "parseCopilotInstructions"
    - from: "src/adapters/copilot/parsers/prompts.parser.test.ts"
      to: "src/adapters/copilot/parsers/prompts.parser.ts"
      via: "import { parseCopilotPrompts }"
      pattern: "parseCopilotPrompts"
---

<objective>
Write TDD tests for the Copilot instructions and prompts parsers introduced in Plan 01. Tests use real services on tmpdir — the same pattern as existing `parsers.test.ts` in the MCP tests.

Purpose: Ensure correctness of parsers under edge cases (no frontmatter, missing files/dirs, compound extensions, applyTo extraction, mode/agent aliasing).
Output: Two test files. Tests go RED before Plan 01 is executed, GREEN after.
</objective>

<execution_context>
@/Users/koenrohrer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/koenrohrer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-custom-instructions-and-prompts/22-RESEARCH.md
@src/adapters/copilot/parsers/mcp.parser.ts
@src/adapters/codex/parsers/prompt.parser.ts
</context>

<feature>
  <name>Copilot instructions and prompts parsers</name>
  <files>
    src/adapters/copilot/parsers/instructions.parser.ts,
    src/adapters/copilot/parsers/instructions.parser.test.ts,
    src/adapters/copilot/parsers/prompts.parser.ts,
    src/adapters/copilot/parsers/prompts.parser.test.ts
  </files>
  <behavior>
parseCopilotInstructions(fileIO, workspaceRoot):

Case 1: workspaceRoot has .github/copilot-instructions.md with content "# Conventions\nBe concise." (no frontmatter)
  -> Returns 1 tool: id='instruction:project:copilot-instructions', name='copilot-instructions', instructionKind='global', body='# Conventions\nBe concise.', applyTo=undefined

Case 2: workspaceRoot has .github/copilot-instructions.md + .github/instructions/typescript.instructions.md (applyTo: "**/*.ts")
  -> Returns 2 tools sorted alphabetically: copilot-instructions first, typescript second
  -> typescript tool: instructionKind='file-pattern', applyTo='**/*.ts', description='Applies to: **/*.ts' (default when no description field)

Case 3: workspaceRoot has .github/instructions/style.instructions.md with frontmatter: "---\napplyTo: '**'\ndescription: Style guide\n---\nContent"
  -> Returns tool with description='Style guide' (description from frontmatter wins over applyTo fallback)

Case 4: .github/ directory does not exist (fresh workspace)
  -> Returns [] without throwing

Case 5: .github/copilot-instructions.md does not exist but .github/instructions/ has files
  -> Returns only the per-file instruction tools, no global entry

---

parseCopilotPrompts(fileIO, workspaceRoot):

Case 6: workspaceRoot has .github/prompts/refactor.prompt.md with frontmatter "---\ndescription: Refactor code\nmode: agent\n---\nBody"
  -> Returns 1 tool: id='prompt:project:refactor', name='refactor', instructionKind='prompt', description='Refactor code', mode='agent', body='Body'

Case 7: .github/prompts/noheader.prompt.md with no frontmatter (raw markdown only)
  -> Returns tool with description=undefined, mode=undefined, body=full file content

Case 8: .github/prompts/ directory does not exist
  -> Returns [] without throwing

Case 9: .github/prompts/ has a file named something.md (not .prompt.md compound extension)
  -> File is NOT included in results (compound extension filter)
  </behavior>
  <implementation>
Follow exact RED -> GREEN -> REFACTOR cycle:

**RED phase:**
Create both test files with all test cases. Run `npm test` — tests MUST FAIL (parser files don't exist yet in Plan 01 or are stubs that return []).

Commit: `test(22-02): add failing tests for Copilot instructions and prompts parsers`

**GREEN phase:**
Plan 01 creates the parser implementations. After Plan 01 executes:
Run `npm test` — all tests in both files MUST PASS.

If tests fail after Plan 01:
- Read the failure output carefully
- Identify whether it is a test bug or implementation bug
- Fix the implementation (do not weaken the tests)
- Run tests again until GREEN

Commit: `feat(22-02): Copilot instructions and prompts parsers pass all tests`

**REFACTOR (if needed):**
Clean up test helper duplication (extract shared tmpdir setup if both test files share boilerplate).
Run tests again — MUST PASS.

Commit (only if refactored): `refactor(22-02): clean up parser test helpers`

Test structure: Use real FileIOService + real tmpdir (os.tmpdir() + random suffix). Write .md files into tmpdir subdirectories using fs.writeFile before each test. Clean up with fs.rm({ recursive: true }) after each test. This matches the pattern in existing mcp parsers.test.ts.

Look at the existing test at `src/adapters/copilot/parsers/mcp.parsers.test.ts` (or similar) to confirm the exact test helper pattern (real services on tmpdir).
  </implementation>
</feature>

<verification>
1. RED: `npm test` fails with "Cannot find module" or similar for instructions.parser.ts before Plan 01 is executed
2. GREEN: `npm test` passes all cases listed in `<behavior>` above after Plan 01 is executed
3. No test uses mocking for FileIOService — real service on tmpdir only
4. Compound extension test (Case 9) verifies the `.prompt.md` filter, not `.md`
</verification>

<success_criteria>
- Both test files exist with all 9 behavioral cases covered
- Tests are RED before Plan 01 parser files exist
- Tests are GREEN after Plan 01 parser files exist
- Test files follow real-services-on-tmpdir pattern (no mocks)
</success_criteria>

<output>
After completion, create `.planning/phases/22-custom-instructions-and-prompts/22-02-SUMMARY.md`
</output>
